

----------------------------------- Миксины как функции ------------------------------------------

 @mixin margin-x($mr, $ml) { ---------  функция
  margin-right: $mr; ----------------- определенное свойство для функции
  margin-left: $ml; ------------------ определенное свойство для функции
}

.mx-10 {
  @include margin-x(10px, 10px); ------------- значение для свойств
}

 Для чего? Если нужно многим классам указать, например, background-color, то это поможет.
 
 @mixin margin-x($mr, $ml) {
   margin-right: $mr;
   margin-left: $ml;
 }

 .mx-10 {
   @include margin-x(10px, 10px); - без указания каждого свойства margin пишем margin-x(10px,10px)
 }

 .mx-15 {
   @include margin-x(15px, 15px);
 }

 .mx-20 {
   @include margin-x(20px, 20px);
 }

--------------------------------------------------------------------------------------------------

 Мы можем передавать целый CSS код.

 Получить этот контент внутри миксина можно с помощью конструкции @content, которая возьмёт всё 
 тело из вызова миксина и добавит его туда, где была указана конструкция @content.


 @mixin btn {
  display: block;
  padding: 20px;

  font-weight: bold;
  font-size: 0.8em;
  color: #333;

  @content; ----------------------- конструкция вот эта
}

--------------------------------------------------------------------------------------------------
 Задача.

 1) Создайте миксин bg-gradient, принимающий 3 цвета. С помощью этих трёх цветов создайте линейный 
    градиент.
 2) Необходимо указать ещё одно свойство background с заранее заданным цветом.

 @mixin bg-gradient($first-color, $second-color, $third-color) {
   background: $second-color;
   background: linear-gradient(90deg, $first-color 0%, $second-color 35%, $third-color 100%);
 }



------------------------------------- Типы данных ------------------------------------------------

 К простым типам данных относятся:
 1) Числа.
 2) Строки.
 3) Булевый тип.

 Число в препроцессоре состоит из самого значения и единицы измерения:
 $number: 30px; - 30 число, а px единицца измерения.


 Примеры при различных операциях:
 1) 10px + 10px // => 20px
 2) 120px - 20px // => 100px
 10px * 10px // => 100px*px --------- ошибка переумножаться будет и единица измерения.
                                      Решение проблемы просто у одного числа не указыать 
                                      единицу измерения.
--------------------------------------------------------------------------------------------------

 Булевой тип: правда или ложь.

 $dark-mode: true;
 $small-text: false;

--------------------------------------------------------------------------------------------------

 Строки:

 Создать строку, используются одинарные ' ' или двойные " " кавычки.

 $string: "Hello, World";
 a {
  &:before {
    content: $string;
  }
 }

 После компиляции - a:before {
                      content: "Hello, World";
                    }

 Конкатенация. Строки в SASS мы можем складывать.

 $hello: "Hello";
 $world: "World";
 $name: "Nikita";

 a.world {
  &:before {
    content: $hello + ", " + $world;
  }
 }

 После компиляции - a.world:before {
                      content: "Hello, World";
                    }

 Интерполяция. - "#{$one}, #{$two}"; - возможность выполнять выражения внутри строки.

 $hello: "Hello";
 $world: "World";
 $name: "Nikita";

 a.world {
  &:before {
    content: "#{$hello}, #{$world}";
  }
 }

--------------------------------------------------------------------------------------------------

 @mixin icon($name, $size) {
  .icon-#{$name} {
    background: url("images/icon-#{$name}.svg");
    width: #{$size}px;
    height: #{$size}px;
  }
 }

 @include icon("login", "32");

 Здесь подставляется $name для имя иконки при ее изменении будет меняться блок к котором 
 применяются данные стили. Тоже самое к пути до url("images/icon-#{$name}.svg");

 width: #{$size}px;. В данном случае мы не указываем кавычки, так как значение свойства width 
 должно указываться без них. Так как SASS все интерпретирует как строки

--------------------------------

 Проверка типа данных:

 type-of - узнать тип данных в переменной.

 @debug type-of(имя переменной) - любом месте своего SASS файла.

 @debug type-of($value); // => number




======================================== Функции =================================================

 Создать функцию - @function уникальное имя.

 @function square


 @function square($number) { ----------------------- Возведение в квадрат
  $result: $number * $number;
 }

 @return - возвращает результат функции.
 
 @function square($number) {
  $result: $number * $number;
  @return $result;
 }

 @return $result; ----------------------- возвращает результат.

--------------------------------------------------------------------------------------------------
 
 Пример готовой функции

 $side: 10;

 @function square($number) {
   $result: $number * $number;
   @return $result;
 }

 .square {
   width: #{square($side)}px;
   height: #{square($side)}px;
 }


 После компилиции - .square {
                      width: 100px;
                      height: 100px;
                     }



 Можно записать проще. @function square($number) {
                         @return $number * $number;
                       }


 Возвращение другой функции ----------

 Это удобно в больших проектах, когда одна функция считает аргументы для второй функции и 
 вызывает её. Две функции в одном примере одна возводит в квадрат а другая убирает минусы 
 перед числами


  @function square($number) {
   @return $number * $number;
  }

  @function abs-square-sum($number-one, $number-two) {
    $number-one: abs($number-one);
    $number-two: abs($number-two);

    $sum: $number-one + $number-two;

    @return square($sum);
   }

   @debug abs-square-sum(-10, 5);

 Результатом выполнения abs-square-sum(-10, 5) станет число 225.

--------------------------------------------------------------------------------------------------

 Что использовать Миксины или Функции?

 @mixin big-text($size) {
  font-size: #{$size * 1.5}px;
 }
 
 ИЛИ

 @function multiply-by-one-and-half($number) {
  @return $number * 1.5;
 }


 1) Миксины — это, в первую очередь, возможность переиспользования CSS-свойств.

 2) Главный смысл функций в том, что нам не важно, где производить умножение на полтора. 
    Эту функцию можно использовать и для вычисления отступов, высоты/ширины. Мы не завязаны на 
    каком-то конкретном свойстве или единице измерения.

--------------------------------------------------------------------------------------------------
 Создайте функцию grid-container-width, которая высчитывает ширину в зависимости от того, 
 сколько колонок мы хотим использовать.

 Вам доступны 2 переменные:
 $grid-width — ширина одной колонки.
 $gutter-width — отступ между колонками.

 @function grid-container-width($columns-count) {
   @return $columns-count * $grid-width + ($columns-count - 1) * $gutter-width;
 }
--------------------------------------------------------------------------------------------------


------------------------------------ Условные конструкции ----------------------------------------

 if/else

 1) Условная конструкция — конструкция, которая направляет работу скрипта по одному из 
                           нескольких путей, в зависимости от того, истинно ли условие внутри 
                           конструкции.
 2) Условие — любое выражение, которое можно свести либо к истинности, либо ко лжи. 
              Например, выражение 2 + 2 = 4 истинно, а 2 + 5 = 1 — нет.


 $dark-mode: true;

 @mixin card { ---------------------- определили базовые цвета «по умолчанию».
   // Цвета для светлой темы
   $primary-color: #f9f9f9;
   $text-color: #424242;

   @if ($dark-mode == true) { ------ равно ли значение переменной 1) да - заходим в if 
                                                                  2) нет - игнорируем что внутри
     // Если условие сработает, то мы просто перезапишем значения переменных.
     $primary-color: #161625;
     $text-color: #e1e1ff;
   }

   .card {
     .card-body {
       background: $primary-color;
       color: $text-color;
     }
   }
 }

----------------------------------- Операторы сравнения ------------------------------------------


 != — не равно. Результат полностью противоположен оператору ==. Если левая и правая часть 
      выражения не равны, то результат будет true.
 > — левая часть выражения больше правой.
 >= — левая часть выражения больше, либо равна правой.
 < — левая часть выражения меньше правой.
 <= — левая часть выражения меньше, либо равна правой.

 Где нам могут понадобиться такие выражения?

 Пример:

 Усть некоторое значение font-size. Если это значение меньше 16 пикселей, то при ширине 
 viewport до 768px, оно должно быть увеличено в полтора раза.

 $main-font-size: 14px;

 html {
  font-size: $main-font-size;
 }

 body {
   padding: 1rem 3rem;
 }

 @media (max-width: 768px) {
   @if ($main-font-size < 16px) {
     html {
       font-size: $main-font-size * 1.5;
     }
   }
 }


---------------------------------- Логические операторы ------------------------------------------

 and ­— логический оператор «И». Вернет true, если оба выражения истины.
 or — логический оператор «ИЛИ». Вернет true, если хотя бы одно выражение истинно.
 not — логический оператор отрицания «НЕ». Вернет true, если выражение ложно.


 $dark-mode: true;
 $device: 'mobile';

 @mixin card {
   // Цвета для светлой темы
   $primary-color: #f9f9f9;
   $text-color: #424242;

   @if ($dark-mode == true and $device == 'mobile') {
     // Если условия сработают, то мы просто перезапишем значения переменных.
     $primary-color: #161625;
     $text-color: #e1e1ff;
   }

   .card {
     .card-body {
       background: $primary-color;
       color: $text-color;
     }
   }
 }

 Два условия для выполнения должны быть верны


 Оператор else -----------------------------------------------------------------------------------

 Блок кода внутри @else выполнится, если выражение в @if ложно.

 @if ($dark-mode == true and $device == 'mobile') {
    // Если условия сработают, то мы просто перезапишем значения переменных.
    $primary-color: #161625;
    $text-color: #e1e1ff;
  } 
    @else {
     // Цвета для светлой темы
     $primary-color: #f9f9f9;
     $text-color: #424242;
   }

--------------------------------------------------------------------------------------------------

----------------------------------- Сложные типы данных ------------------------------------------

 SASS предоставляет еще 2 типа данных:
 Списки (list);
 Ассоциативные массивы (map).

 nth() - можем узнать значение списка по его индексу.


 С помощью функции nth() возьмем второй элемент списка.

 $main-font: "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
 
 .font-roboto {
   font-family: nth($main-font, 2);
 }

 Результат: .font-roboto {
              font-family: Roboto;
            }

 join() - обьединяет списки.

 $main-colors: #007bff, #6610f2;
 $secondary-colors: #6f42c1, #dc3545;

 $theme-colors: join($main-colors, $secondary-colors);


 append() - если же мы хотим добавить один элемент в существующий список.

 $main-colors: #007bff, #6610f2;
 $main-colors: append($main-colors, #6f42c1); - внутри находится переменная куда нужно добавить.

 .box-bg {
   background: nth($main-colors, 3);
 }


---------------------------------- Ассоциативные массивы -----------------------------------------

 Ассоциативные массивы - ключ: значение.

 $font-weights: (light: 200, normal: 400, medium: 500, bold: 800);

 map.get() - выбрать значение по ключу.
 @use "sass:map"; - для работы функции, которые указываются через конструкцию map.


 Пример:

 @use "sass:map";
 $font-weights: (light: 200, normal: 400, medium: 500, bold: 800);

 .warning {
   font-weight: map.get($font-weights, bold);
 }
 .user-name {
   font-weight: map.get($font-weights, normal);
 }

--------------------------------------------------------------------------------------------------
 map.merge() - добавления нового значения в ассоциативный массив или объединения двух разных.

 Пример:

 @use "sass:map";

 $main-colors: (primary: #007bff, secondary: #6610f2);
 $secondary-colors: (purple: #6f42c1, red: #dc3545);

 $theme-colors: map.merge($main-colors, $secondary-colors);

 Вывод:
 $theme-colors: (
  primary: #007bff,
  secondary: #6610f2,
  purple: #6f42c1,
  red: #dc3545
 );

 Важно: если в двух ассоциативных массивах содержатся одинаковые ключи, то будет выбрано 
        значение, которое было последним.
--------------------------------------------------------------------------------------------------


----------------------------------------- Циклы --------------------------------------------------

 5 элементов: cat, dog, whale, bird, fish. Для каждого из элемента списка нужно составить класс 
   следующего вида:

 .icon-cat {
   height: 32px;
   width: 32px;

   background: url("../icon/svg/cat.svg");
 }

 Решение:

 $icons: "cat", "dog", "whale", "bird", "fish";

 @mixin icon-32($icon-name) {
  .icon-#{$icon-name} {
    height: 32px;
    width: 32px;

    background: url("../icon/svg/#{$icon-name}.svg");
  }
}
 
 @include icon-32(nth($icons, 1));
 @include icon-32(nth($icons, 2));
 @include icon-32(nth($icons, 3));
 @include icon-32(nth($icons, 4));
 @include icon-32(nth($icons, 5));


 Но что делать если их сотни? Помогут циклы.

 Запись с помощью цикла for


 $icons: "cat", "dog", "whale", "bird", "fish";

 @mixin icon-32($icon-name) {
  .icon-#{$icon-name} {
    height: 32px;
    width: 32px;

    background: url("../icon/svg/#{$icon-name}.svg");
   }
  }

 @for $i from 1 through 5 {
   @include icon-32(nth($icons, $i));
  }


--------------------------------------------------------------------------------------------------
 
 Цикл for:

 @for - позволяет задать нам необходимое количество повторений.

 from 1 to 5 - Счётчик с ключевым словом to считается до конечного числа, не включая конечное 
               число.
 from 1 through 5 - Счётчик с ключевым словом through считается до конечного числа, включая 
                    конечное число.

 @for $i from 1 to 3 {                          - цикл for, имя переменной, счетчик
  
   $side: $i * 10;

   .square-#{$side} {
     display: block;
 
     width: #{$side}px;
     height: #{$side}px
    }
   }

  .square-10 {
    display: block;
    width: 10px;
    height: 10px;
   }

  .square-20 {
    display: block;
    width: 20px;
    height: 20px;
   }
--------------------------------------------------------------------------------------------------

 Если количество элементов в списке большое, то в ручную их пересчитывать проблематично для 
 указания счетчика.
 
 Решение:

 length() - посчитает количество элементов

 $icons: "cat", "dog", "whale", "bird", "fish";
 $icons-length: length($icons);

 @mixin icon-32($icon-name) {
  .icon-#{$icon-name} {
    height: 32px;
    width: 32px;

    background: url("../icon/svg/#{$icon-name}.svg");
   }
  }

 @for $i from 1 through $icons-length {
   @include icon-32(nth($icons, $i));
  }
--------------------------------------------------------------------------------------------------

 @each - перебирает значения списка или ассоциативного массива и для каждого значения выполняет 
         блок кода.

 $list: 1, 2, 3;

  @each $number in $list {
   // блок кода
  }

 1) Ключевое слово @each.
 2) Указывается переменная.
 3) Указывается список, из которого эти значения берутся.

 $icons: "cat", "dog", "whale", "bird", "fish";

 @mixin icon-32($icon-name) {
   .icon-#{$icon-name} {
     height: 32px;
     width: 32px;

     background: url("../icon/svg/#{$icon-name}.svg");
   }
  }

 @each $icon in $icons {
  @include icon-32($icon);
 }


--------------------------------------------------------------------------------------------------

Ассоциативными массивами всё немного иначе. Ассоциативные массивы - ключ: значение.
--------------------------------------------------------------------------------------------------
 $icons: (
  "cat": (32, 64, 128),
  "dog": (32, 64, 128),
  "whale": (32, 64),
  "bird": (16, 32, 64, 128),
  "fish": (32, 64)
);

@mixin icon($icon-name, $icon-size) {
  .icon-#{$icon-size}-#{$icon-name} {
    height: #{$icon-size}px;
    width: #{$icon-size}px;

    background: url("../icon/svg/#{$icon-size}/#{$icon-name}.svg");
  }
}

@each $icon, $sizes in $icons {
  @each $size in $sizes {
    @include icon($icon, $size);
  }
}
--------------------------------------------------------------------------------------------------
        
 Совет: всегда обращайте внимание на то, какую операцию вы делаете. Если нужно выполнить блок 
        кода определённое количество раз, то цикл @for. При работе со списками/массивами и при 
        использовании их значений используйте цикл @each.
--------------------------------------------------------------------------------------------------

 Цикл while:

 @while условие - он работает по принципу пока выполняется условие.

 Пример:

 $count: 1;

 @while $count < 5 {
  .font-size-#{$count} {
    font-size: #{$count}em;
  }

  $count: $count + 1;
 }
 
--------------------------------------------------------------------------------------------------

 Cложно:

 @use "sass:map";
 @use "sass:string";

 $theme-colors: (
   "primary":    ("light": "#f5e6e8", "dark": "#1b262c"),
   "secondary":  ("light": "#d5c6e0", "dark": "#0f4c75"),
   "success":    ("light": "#aaa1c8", "dark": "#3282b8"),
   "info":       ("light": "#967aa1", "dark": "#f9f9f9"),
   "warning":    ("light": "#192a51", "dark": "#bbe1fa"),
 );

@mixin colors($colors, $tone: "light") {
  @each $color-name, $color-value in $theme-colors {
    $color: unquote(map.get($color-value, $tone));

    .bg-#{$color-name} {
      background: $color;
    }
    .text-#{$color-name} {
      color: $color;
    }
  }
}
