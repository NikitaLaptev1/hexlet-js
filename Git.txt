						
						      Зачем нужен Git?

Независимо от выбранного языка или направления разработки, код, который пишет программист, остается обычным текстом, 
записанным в множестве файлов. Эти файлы регулярно добавляются, удаляются и изменяются. И в процессе работы над ними 
возникает множество вопросов:

1) Как не потерять файлы с исходным кодом? Если сломается компьютер?
2) Как вспомнить, что и где менялось недавно?
3) Как защититься от случайных исправлений и удалений?
4) Как отменить изменения, если они оказались некорректными?
5) Как работать над кодом одновременно двум и более программистам?


Схема последовательость. ------------------------------------------------------------------------------------

1) Команда Git init создает репозиторий — директорию .git, которая содержит все необходимые для работы Git-файлы.

2) Добавление в репозиторий выполняется команда подготовки файлов Git add <путь до файла>.

3) Коммит git commit -m 'add README.md' — это операция, которая берет все подготовленные изменения (они могут включать 
любое количество файлов) и отправляет их в репозиторий как единое целое. | -m - добавление описания коммита.

Коммит - фиксация изменений, добавленных в индекс внутри репозитория

Можно ли закоммитить неотслеживаемые файлы? - Нет, сначала их нужно добавить в индекс.

Зачем нужен индекс (stage)? - Для формирования набора файлов, которые попадут в один коммит.

ЗАДАЧА 1:

Репозиторий для работы находится в директории code-user. Перейти в неё нужно в терминале.

Добавьте в репозиторий два файла двумя разными коммитами: ----------------------------------------------------------------

1) hexlet.txt с текстом Hello, Hexlet!
2) index.html с текстом <h1>Мама, я коммичу</h1>


cd code-user/ # Переходим в директорию code-user
echo 'Hello, Hexlet!' > hexlet.txt
echo '<h1>Мама, я коммичу</h1>' > index.html
git add hexlet.txt
git commit -m 'add hexlet.txt'
git add index.html
git commit -m 'add index.html'


Добавить репозиторий на GitHub -------------------------------------------------------------------------------------------

1) Создать репозиторий - mkdir 'name'
2) Перейти в созданную директорию - cd 'name'
3) Создать репозиторий - git init
4) Создать необходимые файлы для работы - echo 'текст' > 'name'
5) Добавить в репозиторий - git add 'необходимый файл' 
6) Закоммить файл - git commit -m 'add <имя файла>'

git remote add origin git@github.com:<ИМЯ НА ГИТХАБЕ>/<ИМЯ РЕПОЗИТОРИЯ НА ХАБЕ>.git
git branch -M main
git push -u origin main

Клонирование из Github, если локально утерен файл: -----------------------------------------------------------------------
git clone 'SSH code'


Что если разработчик один, на разных локальных компьютерах? --------------------------------------------------------------

Бывает такое, что один разработчик работает над одним проектом с разных компьютеров, на каждом из которых 
своя собственная копия репозитория. Перед началом работы нужно всегда 
выполнять команду git pull --rebase, которая скачивает из внешнего репозитория новые коммиты и добавляет их в 
локальный репозиторий.


git clone 'ссылка на репозиторий'  (клон откуда и куда)
cd code-user/ (переход в директорию)
echo 'I like to change files' >> hexlet.txt (добавление строки)
echo '<h1>С помощью Git можно писать книги</h1>' > index.html (замена содержимого)
git add hexlet.txt index.html (добавление изменений в репозиторий и путь до файла)
git config --global user.email "you@example.com" (указали имейл)
git config --global user.name "Your Name" (указали имя)
git commit -m 'fix hexlet.txt and index.html' (закоммили)
git push (запушили на гитхабе файл, обновили)


	---------------------------- АНАЛИЗ ИСТОРИИ ИЗМЕНЕНИЙ (коммитов) ----------------------------

Один коммит, одно логически связанное изменение (возможно одна задача)!!!!!

Git Log ----------------------------------------------------------------------------------------------------

Показывает список всех выполненных коммитов, отсортированных по дате добавления (сверху самые последние):

git log (-p, показывает сразу вмете с диффом)

# Ниже неполный вывод истории проекта

commit 5120bea3e5528c29f8d1da43731cbe895892eb6d ---------- Хеш
Author: tirion <tirion@got.com>
Date:   Thu Sep 17 18:04:19 2020 -0400

    add new content

commit e6f625cf8433c8b1f1aaed58cd2b437ec8a60f27 ---------- Хеш
Author: tirion <tirion@got.com>
Date:   Thu Sep 17 16:14:09 2020 -0400

    add INFO.md


Git Show 'хеш': ---------------------------------------------------------------------------------------------

git show 5120bea3e5528c29f8d1da43731cbe895892eb6d ------ Хеш
# Тут выводится диф между этим коммитом и предыдущим

diff --git a/INFO.md b/INFO.md
index d5225f8..40f51f1 100644
--- a/INFO.md
+++ b/INFO.md
@@ -1 +1,2 @@
 git is awesome!
+new line
diff --git a/README.md b/README.md
index ffe7ece..00fd294 100644
--- a/README.md
+++ b/README.md
@@ -1 +1 @@
-Hello, Hexlet!
+Hello, Hexlet! How are you?

Git Blame <путь до файла>. Эта команда выводит файл и рядом с каждой строчкой показывает того, кто 
ее менял и в каком коммите.

git blame INFO.md

e6f625cf (tirion 2020-09-17 16:14:09 -0400 1) git is awesome!
5120bea3 (tirion 2020-09-17 18:04:19 -0400 2) new line


Git Grep - ищет совпадение с указанной строкой во всех файлах проекта.

1) git grep line
   INFO.md:new line

# Флаг i позволяет искать без учета регистра
2) git grep -i hexlet
   README.md:Hello, Hexlet! How are you?

# Поиск в конкретном коммите
3) git grep Hexlet 5120bea

# Поиск по всей истории
# rev-list возвращает список хешей коммитов
4) git grep Hexlet $(git rev-list --all)


Git Revert ---------------------------------------------------------------------------------------------------------------

# Этой команде нужен идентификатор коммита
# Это коммит, которым мы удалили файл PEOPLE.md
git revert aa600a43cb164408e4ad87d216bc679d097f1a6c

[main 65a8ef7] Revert "remove PEOPLE.md"
 1 file changed, 1 insertion(+)
 create mode 100644 PEOPLE.md
# В проект вернулся файл PEOPLE.md

git log -p

commit 65a8ef7fd56c7356dcee35c2d05b4400f4467ca8
Author: tirion <tirion@got.com>
Date:   Sat Sep 26 15:32:46 2020 -0400

    Revert "remove PEOPLE.md"

    This reverts commit aa600a43cb164408e4ad87d216bc679d097f1a6c.


Git Reset ----------------------------------------------------------------------------------------------------------------

Это опасная операция, которую нужно делать только в том случае, если речь идет про новые коммиты, которых нет 
ни у кого, кроме вас.

# добавляем новый коммит, который мы сразу же удалим
echo 'test' >> INFO.md
git add INFO.md
git commit -m 'update INFO.md'

[main 17a77cb] update INFO.md
 1 file changed, 1 insertion(+)
 # Важно, что мы не делаем git push

git reset --hard HEAD~

HEAD is now at 65a8ef7 Revert "remove PEOPLE.md"
# Если посмотреть git log, то последнего коммита там больше нет

--mixed - в таком варианте reset отправляет изменения последнего коммита в рабочую директорию.


   ------------------------------------------ Изменения последнего коммита ------------------------------------------

--amend (только в последний коммит)

echo 'experiment with amend' >> INFO.md
echo 'experiment with amend' >> README.md

git add INFO.md

# Забыли сделать подготовку README.md к коммиту
git commit -m 'add content to INFO.md and README.md'


# Увидели, что забыли добавить файл. Добавляем

git add README.md
git commit --amend

# После этой команды откроется редактор, ожидающий ввода описания коммита
# Здесь можно поменять сообщение или выйти из редактора, оставив старое

--no-edit

Чтобы не открывался редактор для ввода описания коммита к команде git commit --amend 
можно добавить опцию --no-edit.


Вы сделали коммит, но забыли добавить в него пару файлов. Измените последний коммит так, чтобы он 
содержал все три файла одновременно.

cd code-user/ # Переходим в директорию code-user
git add index.html
git add todo.md
git commit --amend


   ------------------------------------------------------ Индекс ------------------------------------------------------


Индекс — это специальная промежуточная область, в которой хранятся изменения файлов на пути от рабочей директории до репозитория.
Короче, добавлять исправления и новые файлы в одном коммите неудобно, потому что если откатить все это то вместе с 
иправлениями, а они нужны.

1) Стандартный способ работы с индексом — это добавление или изменение файлов и последующий коммит:
	
	git add somefile
	git commit -m 'add somefile'

2)  1-2 файла (определенных). Она автоматически добавляет эти файлы в индекс и затем в коммит. 

 	echo 'new data' >> INFO.md
        # Не нужно явно вызывать git add
        git commit INFO.md -m 'update INFO.md'

3) Мы исправили много файлов и хотим добавить их в коммит сразу все.

	git add .

4) Команда — это коммит с одновременным добавлением всего в индекс:
	
	# Флаг -a автоматически добавляет все изменения рабочей директории в индекс
	git commit -am 'do something'

5) С помощью этой команды можно очень точно выбрать то, что должно попасть в коммит, а что нет.

	git add -i


6) Используя интерактивный режим git add, разбейте изменения на две части и затем добавьте в индекс одну из них. Не выходя 
   из интерактивного режима, выведите на экран состояние изменений, подготовленных к коммиту, с помощью status.
	
	cd code-user/ # Переходим в директорию code-user
	git add -i
	patch
	1
	# Подтверждаем выбор нажатием Enter
	s
	y
	n
	status
	quit
	git commit -m '+2/-0'



 --------------------------------------------- Перемещение по истории (Загрузиться) ------------------------------------

Загружать в рабочую директорию состояние кода на момент выполнения любого коммита. Посмотрим:

1) git log --oneline

   fc74e2d update README.md
   65a8ef7 Revert "remove PEOPLE.md"
   5120bea add new content

2) git checkout <хеш коммита> => Загружает в рабочую директорию состояние репозитория на момент нужного коммита

   Note: switching to 'e6f625c'.

3) Сами изменения никуда не делись, и мы снова можем вернуться на последний коммит следующей командой:
   
   git checkout main

4) Вернуться обратно после чекаута

   git switch - 


Где я??? ---------

  git branch => Узнать текущий загруженный коммит.
   
   * main ,если из прошлого => * (HEAD detached at e6f625c)
                                  main


Вы сделали несколько коммитов в репозиторий и в каком-то из них сохранили файл todo.md со списком задач, а потом 
удалили этот файл. Найдите в истории коммит, в котором был добавлен файл todo.md.

cd code-user/ # Переходим в директорию code-user
git log -p --oneline -- todo.md
git checkout 7c2fcf8



------------------------------------------------- Понимание Git ---------------------------------------------------------

  git log --graph => Вывод коммитов проекта:

* commit e7bb5e51f96e572084f6c04ba3312e32ce6b8c0f (HEAD -> main, origin/main, origin/HEAD)
|
|     update README.md
|
* commit 65a8ef7fd56c7356dcee35c2d05b4400f4467ca8
|
|     Revert "remove PEOPLE.md"

Полоска слева. Она отражает связи между коммитами. Каждый новый коммит базируется на коде предыдущего коммита.

Main - список коммитов (ветка)

Удаление последнего коммита выглядит так:

# HEAD~1 означает: взять голову и удалить, начиная от нее, один коммит
# То есть только последний коммит

git reset --hard HEAD~1


 ------------------------------------------------- Ветки ---------------------------------------------------

Гит позволяет отпочковываться от основного списка, формируя «ветки». То есть создается отдельный список 
коммитов, который идет мимо main.

Параллельную разработку в Git можно осуществлять с помощью веток, что позволяет не пересекать 
их код между собой

1) Переход на ветку!

   git switch 'name branch'

В репозитории создано 2 дополнительные ветки, помимо main.
Переключитесь на ветку refactoring и удалите два последних коммита с помощью git reset --hard.
Переключитесь на ветку working-on-html и в этой ветке сделайте коммит, отредактировав файл index.html следующим образом:

Замените содержимое тега h1 на «Ветки в Git достойны отдельного курса»
Замените содержимое тега p на «Ветки являются ссылками на определённый коммит.»

 cd code-user 
 git switch refactoring - перешли на ветку 'refactoring'
 git reset --hard HEAD~2 - удалили последних 2 коммита 
 git switch working-on-html - перешли на другую ветку
 # Редактируем и сохраняем файл
 # Можно использовать vim или nano
 vim index.html
 git add index.html
 git commit -m 'fix index.html'


 ------------------------------------- Игнорирование файлов (Gitignore) ------------------------------------
 В процессе работы над любым проектом в директории с кодом создаются файлы, которые не являются частью 
 исходного кода. (кеш, логи, служебные файлы)

 touch .gitignore
 # добавляем в файл правила игнорирования по примеру выше
 git add .gitignore
 git commit -m 'update gitignore'

 Допишите gitignore, чтобы игнорировалась только директория node_modules/ которая находится в корне проекта

 / + node_modules/

ЗАДАЧА. Проигнорируйте и удалите из репозитория, если это необходимо, но не удаляйте из рабочей директории, 
        файлы notes.txt и todo.md, а затем сделайте коммит со всеми изменениями.

 cd code-user
 echo 'notes.txt' > .gitignore  
 echo 'todo.md' >> .gitignore  
 git rm --cached notes.txt                  => файл будет удалён из репозитория, но не из рабочей директории 
 git commit -m 'remove notes.txt from repo' => коммит изменения (удалили notes.txt)
 git add hexlet.txt
 git commit -m 'update hexlet.txt'
 git add .gitignore
 git commit -m 'add .gitignore'


-------------------------------------------------- STASH ---------------------------------------------------
 
 Когда нужно сделать быстрый коммит с исправлением, но не добавляя туда код, над которым идет работа 
 прямо сейчас

 git stash => не удаляет файлы, они попадают в специальное место внутри директории

 git stash => popвернуть спрятанные изменения с помощью команды 

ЗАДАЧА. Создайте файл todo.md с любым содержимым
        Добавьте в файл hexlet.txt строку: «stash не трогает новые файлы, которые еще не добавлены в индекс.» и сделайте коммит только с этим файлом
        Восстановите из Stash сохраненные ранее изменения
        Сделайте еще один коммит, включающий все файлы

        cd code-user/ # Переходим в директорию code-user
        git add . # Так как есть изменения не добавленные в индекс
        git stash
        echo 'Hexlet is awesome!' > todo.md
        echo 'stash не трогает новые файлы, которые еще не добавлены в индекс.' >> hexlet.txt
        git add hexlet.txt
        git commit -m 'refactoring'
        git stash pop
        git add .
        git commit -m 'changes from stash'

 ------------------------------------------ Открытые проекты (опенсорс) ------------------------------------

Open Source Software (OSS; разг. опенсорс) — это программное обеспечение (ПО), код которого открыт 
(его можно посмотреть), и на него почти всегда можно влиять.

Клонирование ------> Ответвление от основной кодовой базы другого репозитория на GitHub
Делается это буквально одной кнопкой «Fork» на странице репозитория.

Запрос на включение изменений кода ------> Запрос на включение изменений в основную ветку репозитория
На странице склонированного репозитория появится кнопка «pull request».
Если ее нажать, то откроется страница, на которой можно указать название пулреквеста и его описание.
Теперь остается ждать, когда разработчики библиотеки его примут, либо отклонят, зададут уточняющие вопросы.
